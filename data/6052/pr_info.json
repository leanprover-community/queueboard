{
  "data": {
    "repository": {
      "pullRequest": {
        "additions": 261,
        "assignees": {
          "nodes": [
            {
              "id": "MDQ6VXNlcjIxMTY1NzA=",
              "login": "Vierkantor"
            }
          ]
        },
        "author": {
          "login": "MohanadAhmed"
        },
        "autoMergeRequest": null,
        "baseRefName": "master",
        "body": "This file provides the basic definitions of matrices composed from columns and rows. The concatenation of two matrices with the same row indices can be expressed as `A = fromColumns A₁ A₂` the concatenation of two matrices with the same column indices can be expressed as `B = fromRows B₁ B₂`.\r\n\r\nWe then provide a few lemmas that deal with the products of these with each other and with block matrices. Two particular lemmas `fromColumns_mul_fromRows_eq_one_comm` and `equiv_compl_fromColumns_mul_fromRows_eq_one_comm` deal with the case of matrix multiplication that gives one as a result. This gives a crude (but usable) replacement for the `Invertible` type which can only be applied to square matrices (with the same index type for rows and columns).\r\n\r\n---\r\n<!-- The text above the `---` will become the commit message when your\r\nPR is merged. Please leave a blank newline before the `---`, otherwise\r\nGitHub will format the text above it as a title.\r\n\r\nTo indicate co-authors, include lines at the bottom of the commit message\r\n(that is, before the `---`) using the following format:\r\n\r\nCo-authored-by: Author Name <author@email.com>\r\n\r\nAny other comments you want to keep out of the PR commit should go\r\nbelow the `---`, and placed outside this HTML comment, or else they\r\nwill be invisible to reviewers.\r\n\r\nIf this PR depends on other PRs, please list them below this comment,\r\nusing the following format:\r\n- [ ] depends on: #abc [optional extra text]\r\n- [ ] depends on: #xyz [optional extra text]\r\n-->\r\n\r\n[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/from-referrer/)\r\n",
        "changedFiles": 2,
        "closed": true,
        "closedAt": "2023-08-02T14:42:23Z",
        "comments": {
          "nodes": [
            {
              "id": "IC_kwDOFcwZ1c5jElr8",
              "body": ":v: MohanadAhmed can now approve this pull request. To approve and merge a pull request, simply reply with `bors r+`. More detailed instructions are available [here](https://bors.tech/documentation/getting-started/#reviewing-pull-requests).",
              "createdAt": "2023-08-02T12:46:24Z",
              "author": {
                "login": "bors"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5jE0fi",
              "body": "> ✌️ MohanadAhmed can now approve this pull request. To approve and merge a pull request, simply reply with `bors r+`. More detailed instructions are available [here](https://bors.tech/documentation/getting-started/#reviewing-pull-requests).\r\n\r\nbors r+",
              "createdAt": "2023-08-02T13:24:05Z",
              "author": {
                "login": "MohanadAhmed"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5jFVBs",
              "body": "Pull request successfully merged into master.\n\n  Build succeeded!\n\n  The publicly hosted instance of bors-ng is deprecated and will go away soon.\n\n  If you want to self-host your own instance, [instructions are here][instructions].\n  For more help, visit [the forum].\n\n  If you want to switch to GitHub's built-in merge queue, visit [their help page][gh].\n\n  [instructions]: https://github.com/bors-ng/bors-ng#how-to-set-up-your-own-real-instance\n  [the forum]: https://forum.bors.tech\n  [gh]: https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue\n\n\n\n  * [Build](https://github.com/leanprover-community/mathlib4/actions/runs/5739595642/job/15555540731)\n  * [Check all files imported](https://github.com/leanprover-community/mathlib4/actions/runs/5739595642/job/15555541085)\n  * [Lint style](https://github.com/leanprover-community/mathlib4/actions/runs/5739595642/job/15555541622)",
              "createdAt": "2023-08-02T14:42:21Z",
              "author": {
                "login": "bors"
              }
            }
          ]
        },
        "commits": {
          "nodes": [
            {
              "commit": {
                "oid": "b53a0fc73eecb522e47d976d8d5a8439a1cf5a6f",
                "additions": 211,
                "deletions": 0,
                "committedDate": "2023-07-22T00:21:59Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "7a97815639607510bc7c01231cf310c6b64b8b87",
                "additions": 1,
                "deletions": 2,
                "committedDate": "2023-07-22T00:45:47Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "3ff666859f19446688642d7f22081aead5b4e35f",
                "additions": 30,
                "deletions": 30,
                "committedDate": "2023-07-22T00:53:46Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "0dcd71ff3d7a0a8e598c6796e50f2ba0cb6611c0",
                "additions": 1,
                "deletions": 1,
                "committedDate": "2023-07-22T00:55:20Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "b89c64e53e99800d6de7fb8d9cd177b9c7974a9f",
                "additions": 85,
                "deletions": 70,
                "committedDate": "2023-07-23T08:32:13Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "67db35c6be53e4f9f22060f3c68d11afb1a72d4f",
                "additions": 9,
                "deletions": 4,
                "committedDate": "2023-07-23T08:39:09Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "1c30cf66c9482a9d127f0c7ff185fbc226d8ed5d",
                "additions": 3,
                "deletions": 3,
                "committedDate": "2023-07-23T08:42:27Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "3748436b5f7aa79d87d67907fa11381b8177bcf5",
                "additions": 3,
                "deletions": 3,
                "committedDate": "2023-07-23T16:52:51Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "e8acb783efa8d1ad9f25374444bef8db09d1731f",
                "additions": 29,
                "deletions": 27,
                "committedDate": "2023-07-31T13:36:02Z",
                "author": {
                  "name": "MohanadAhmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "6c62d95e8a4dd34dcd43dc28b1ad896b101b1d31",
                "additions": 127,
                "deletions": 63,
                "committedDate": "2023-07-31T15:20:36Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "1c674727875f90b7bb51e1ee24d5b0a27d8685da",
                "additions": 4,
                "deletions": 3,
                "committedDate": "2023-07-31T15:25:51Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "50f9ecb22593e3b17e4bb098f6d6f5691b04209b",
                "additions": 25,
                "deletions": 29,
                "committedDate": "2023-07-31T15:54:43Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "943961a42327000fbe5c87972448c2fde5d53f87",
                "additions": 40,
                "deletions": 0,
                "committedDate": "2023-08-01T12:59:30Z",
                "author": {
                  "name": "Mohanad Ahmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "51275ea27ccc42a2895510d3bbd8304715f321b0",
                "additions": 65,
                "deletions": 137,
                "committedDate": "2023-08-02T12:59:18Z",
                "author": {
                  "name": "MohanadAhmed",
                  "email": "m.a.m.elhassan@gmail.com"
                },
                "statusCheckRollup": null
              }
            }
          ]
        },
        "createdAt": "2023-07-22T00:44:21Z",
        "deletions": 0,
        "files": {
          "nodes": [
            {
              "path": "Mathlib.lean",
              "additions": 1,
              "deletions": 0
            },
            {
              "path": "Mathlib/Data/Matrix/ColumnRowPartitioned.lean",
              "additions": 260,
              "deletions": 0
            }
          ]
        },
        "headRefName": "MohanadAhmed/ColRowPartitionedMats",
        "headRefOid": "51275ea27ccc42a2895510d3bbd8304715f321b0",
        "headRepository": {
          "name": "mathlib4",
          "owner": {
            "login": "leanprover-community"
          }
        },
        "headRepositoryOwner": {
          "login": "leanprover-community"
        },
        "id": "PR_kwDOFcwZ1c5WIscT",
        "isCrossRepository": false,
        "isDraft": false,
        "labels": {
          "nodes": [
            {
              "id": "LA_kwDOFcwZ1c8AAAABAt13Ow",
              "color": "bfd4f2",
              "name": "delegated"
            },
            {
              "id": "LA_kwDOFcwZ1c8AAAABViJjTQ",
              "color": "33DBEC",
              "name": "t-algebra"
            }
          ]
        },
        "latestReviews": {
          "nodes": [
            {
              "id": "PRR_kwDOFcwZ1c5c6j5y",
              "body": "I went through and cleaned up the proofs. If you're happy with the changes, then this looks ready to me.\r\n\r\nThanks!\r\n\r\nbors d+",
              "state": "APPROVED",
              "author": {
                "login": "Vierkantor"
              },
              "submittedAt": "2023-08-02T12:46:22Z"
            }
          ]
        },
        "maintainerCanModify": false,
        "mergeCommit": null,
        "mergeStateStatus": "UNKNOWN",
        "mergeable": "UNKNOWN",
        "mergedAt": null,
        "mergedBy": null,
        "milestone": null,
        "number": 6052,
        "potentialMergeCommit": null,
        "projectCards": {
          "nodes": []
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "THUMBS_DOWN",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "LAUGH",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "HOORAY",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "CONFUSED",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "HEART",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "ROCKET",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "EYES",
            "users": {
              "nodes": []
            }
          }
        ],
        "reviewDecision": "APPROVED",
        "reviewRequests": {
          "nodes": []
        },
        "reviews": {
          "nodes": [
            {
              "id": "PRR_kwDOFcwZ1c5cqSQX",
              "body": "Sorry for taking a while to get around to your review. Overall I like the structure of your work, there are just a few things that we need to fill in and clean up.\r\n\r\nI propose some extra lemmas that will noticeably change your proofs, so I will look at the style of proofs next time.",
              "state": "COMMENTED",
              "author": {
                "login": "Vierkantor"
              },
              "submittedAt": "2023-07-31T12:20:20Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5crD5k",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "MohanadAhmed"
              },
              "submittedAt": "2023-07-31T13:34:35Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5csL6v",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "MohanadAhmed"
              },
              "submittedAt": "2023-07-31T15:28:08Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5c6j5y",
              "body": "I went through and cleaned up the proofs. If you're happy with the changes, then this looks ready to me.\r\n\r\nThanks!\r\n\r\nbors d+",
              "state": "APPROVED",
              "author": {
                "login": "Vierkantor"
              },
              "submittedAt": "2023-08-02T12:46:22Z"
            }
          ]
        },
        "reviewThreads": {
          "nodes": [
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPss2",
                    "body": "`:` is an operator, so we put spaces around it:\r\n```suggestion\r\nvariable {R : Type _}\r\nvariable {M M₁ M₂ N N₁ N₂ : Type _}\r\n```",
                    "createdAt": "2023-07-31T11:50:54Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  },
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPtoz",
                    "body": "This one is more annoying because you'll have to change every usage: usually we use lowercase variables for the indexing types. This change also helps distinguish between the indexing type `m` and the variable `M` that we often use for an arbitrary matrix.\r\n```suggestion\r\nvariable {R : Type _}\r\nvariable {m m₁ m₂ n n₁ n₂ : Type _}\r\n```",
                    "createdAt": "2023-07-31T11:54:40Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPsyN",
                    "body": "We also put spaces between assumptions:\r\n```suggestion\r\nvariable [Fintype M] [Fintype M₁] [Fintype M₂]\r\nvariable [Fintype N] [Fintype N₁] [Fintype N₂]\r\nvariable [DecidableEq M] [DecidableEq M₁] [DecidableEq M₂]\r\nvariable [DecidableEq N] [DecidableEq N₁] [DecidableEq N₂]\r\n```",
                    "createdAt": "2023-07-31T11:51:17Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPs9z",
                    "body": "Since you drop the `Matrix` namespace below, might as well start doing so here:\r\n```suggestion\r\n  of (Sum.elim A₁ A₂)\r\n\r\n/-- Concatenate together two matrices B₁[M × N₁] and B₂[M × N₂] with the same rows (M) to get a\r\nbigger matrix indexed by [M × (N₁ ⊕ N₂)] -/\r\ndef fromColumns (B₁ : Matrix M N₁ R) (B₂ : Matrix M N₂ R) : Matrix M (N₁ ⊕ N₂) R :=\r\n  of fun i => Sum.elim (B₁ i) (B₂ i)\r\n```",
                    "createdAt": "2023-07-31T11:52:06Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPtuT",
                    "body": "```suggestion\r\ndef toColumns₁ (A : Matrix M (N₁ ⊕ N₂) R) : Matrix M N₁ R := of fun i j => (A i (Sum.inl j))\r\n\r\n/-- Given a column partitioned matrix extract the second column -/\r\ndef toColumns₂ (A : Matrix M (N₁ ⊕ N₂) R) : Matrix M N₂ R := of fun i j => (A i (Sum.inr j))\r\n\r\n/-- Given a row partitioned matrix extract the first row -/\r\ndef toRows₁ (A : Matrix (M₁ ⊕ M₂) N R) : Matrix M₁ N R := of fun i j => (A (Sum.inl i) j)\r\n\r\n/-- Given a row partitioned matrix extract the second row -/\r\ndef toRows₂ (A : Matrix (M₁ ⊕ M₂) N R) : Matrix M₂ N R := of fun i j => (A (Sum.inr i) j)\r\n```",
                    "createdAt": "2023-07-31T11:55:00Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPt-D",
                    "body": "This can be a good `simp` lemma if you put the simpler expression on the right:\r\n\r\n(From now on, everything that I write about columns also applies to rows.)\r\n```suggestion\r\n@[simp]\r\nlemma fromColumns_toColumns (A : Matrix M (N₁ ⊕ N₂) R) :\r\n    fromColumns A.toColumns₁ A.toColumns₂ = A := by\r\n```",
                    "createdAt": "2023-07-31T11:56:06Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPu12",
                    "body": "Could you add a lemma stating [`Function.Injective2 fromColumns`](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Function/Basic.html#Function.Injective2)? Then this proof becomes exactly [`Function.Injective2.eq_iff`](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Function/Basic.html#Function.Injective2.eq_iff).",
                    "createdAt": "2023-07-31T11:58:59Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPvCX",
                    "body": "I'd drop the second half of this name, because there isn't another `transpose_fromColumns_eq` that this can be confused with.\r\n```suggestion\r\nlemma transpose_fromColumns (A₁ : Matrix M N₁ R) (A₂ : Matrix M N₂ R) :\r\n```",
                    "createdAt": "2023-07-31T11:59:51Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPvKX",
                    "body": "We put spaces around all operators.\r\n```suggestion\r\n    (fromRows A₁ A₂) ⬝ B = fromRows (A₁ ⬝ B) (A₂ ⬝ B) := by\r\n```",
                    "createdAt": "2023-07-31T12:00:24Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPvMV",
                    "body": "```suggestion\r\n    A ⬝ (fromColumns B₁ B₂) = fromColumns (A ⬝ B₁) (A ⬝ B₂) := by\r\n```",
                    "createdAt": "2023-07-31T12:00:32Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPvRG",
                    "body": "```suggestion\r\n    (fromRows A₁ A₂) ⬝ (fromColumns B₁ B₂) = fromBlocks (A₁ ⬝ B₁) (A₁ ⬝ B₂) (A₂ ⬝ B₁) (A₂ ⬝ B₂) := by\r\n```",
                    "createdAt": "2023-07-31T12:00:50Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPvUZ",
                    "body": "```suggestion\r\n    fromColumns A₁ A₂ ⬝ fromRows B₁ B₂ = (A₁ ⬝ B₁ + A₂ ⬝ B₂) := by\r\n```",
                    "createdAt": "2023-07-31T12:01:03Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPvYE",
                    "body": "```suggestion\r\n      fromColumns (A₁ ⬝ B₁₁ + A₂ ⬝ B₂₁) (A₁ ⬝ B₁₂ + A₂ ⬝ B₂₂) := by\r\n```",
                    "createdAt": "2023-07-31T12:01:16Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPvbW",
                    "body": "```suggestion\r\n      fromRows (B₁₁ ⬝ A₁ + B₁₂ ⬝ A₂) (B₂₁ ⬝ A₁ + B₂₂ ⬝ A₂) := by\r\n```",
                    "createdAt": "2023-07-31T12:01:29Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPwpk",
                    "body": "The fact that you have to unfold `fromColumns` and `toColumns` etc. so often suggests that there is a missing suite of lemmas (these can all be tagged `@[simp]`):\r\n * `fromColumns A₁ A₂ (Sum.inl i) j = A₁ i j`\r\n * `fromColumns A₁ A₂ (Sum.inr i) j = A₂ i j`\r\n * `toColumns₁ A i j = A (Sum.inl i) j`\r\n * `toColumns₂ A i j = A (Sum.inr i) j`\r\n * `toColumns₁ (fromColumns A₁ A₂) = A₁`\r\n * `toColumns₂ (fromColumns A₁ A₂) = A₂`\r\nThe reason we prefer using `simp` lemmas like these over unfolding is that they can be automated more easily. And writing them in an applied form gives a good balance between unfolding too much and not enough.",
                    "createdAt": "2023-07-31T12:06:56Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPxBh",
                    "body": "Could you add `simp` lemmas saying `fromColumns (fromRows A₁ A₂) (fromRows B₁ B₂) = fromBlocks A₁ A₂ B₁ B₂` and `fromRows (fromColumns A₁ A₂) (fromColumns B₁ B₂) = fromBlocks A₁ A₂ B₁ B₂`?",
                    "createdAt": "2023-07-31T12:08:30Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  },
                  {
                    "id": "PRRC_kwDOFcwZ1c5MQ2nB",
                    "body": "I added them. What use cases do you envision for them?",
                    "createdAt": "2023-07-31T15:28:08Z",
                    "author": {
                      "login": "MohanadAhmed"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPxiM",
                    "body": "To clearly separate the hypotheses from the conclusion, I prefer to keep the conclusion on its own line. (This is a matter of taste, but certainly with long conclusions this is quite important.)\r\n```suggestion\r\nlemma fromColumns_ext_iff (A₁ : Matrix M N₁ R) (A₂ : Matrix M N₂ R) (B₁ : Matrix M N₁ R)\r\n    (B₂ : Matrix M N₂ R) :\r\n    fromColumns A₁ A₂ = fromColumns B₁ B₂ ↔ A₁ = B₁ ∧ A₂ = B₂ := by\r\n```",
                    "createdAt": "2023-07-31T12:10:50Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPyvI",
                    "body": "I didn't really understand the comment you wrote. There seem to be four main messages in here:\r\n * A high-level description of the theorem\r\n * How it relates to other theorems\r\n * What the bijection means\r\n * What the theorem precisely states.\r\n\r\nAll of these are valuable information, but I would present them in this order. Moreover, what the theorem precisely states can be read from the type of the theorem so there is no need to repeat that in the comment.\r\n\r\n```suggestion\r\n/-- Multiplication of a matrix by its inverse is commutative.\r\nThis is the column and row partitioned matrix form of `Matrix.mul_eq_one_comm`.\r\n\r\nThe condition `e : N ≃ N₁ ⊕ N₂` states that `fromColumns A₁ A₂` and `fromRows B₁ B₂` are \"square\".\r\n-/\r\n```",
                    "createdAt": "2023-07-31T12:15:49Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPy-c",
                    "body": "I would move this to be right after `fromColumns_toColumns`, so that each column result is followed by the corresponding result on rows.",
                    "createdAt": "2023-07-31T12:16:45Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MPznk",
                    "body": "I'm not familiar with the `A₁[M₁ × N]` notation, maybe you have a reference for it?",
                    "createdAt": "2023-07-31T12:18:22Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  },
                  {
                    "id": "PRRC_kwDOFcwZ1c5MQKUF",
                    "body": "I just meant the matrix is of rows $M\\_1$ and columns $N$.",
                    "createdAt": "2023-07-31T13:34:35Z",
                    "author": {
                      "login": "MohanadAhmed"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MZtrf",
                    "body": "Almost all of these equalities hold by definition, so the proofs can become `rfl`! This is important because `dsimp` can only use lemmas where the proof is `rfl`.\r\n\r\nI reorganized the code so the `rfl` proofs come first, which allows us to use them in the remainder.\r\n\r\nWhat I did finally is to streamline the non-`rfl` proofs, see also the suggestion below.\r\n\r\n```suggestion\r\n\r\n@[simp]\r\nlemma fromRows_apply_inl (A₁ : Matrix m₁ n R) (A₂ : Matrix m₂ n R) (i : m₁) (j : n) :\r\n    (fromRows A₁ A₂) (Sum.inl i) j = A₁ i j := rfl\r\n\r\n@[simp]\r\nlemma fromRows_apply_inr (A₁ : Matrix m₁ n R) (A₂ : Matrix m₂ n R) (i : m₂) (j : n) :\r\n    (fromRows A₁ A₂) (Sum.inr i) j = A₂ i j := rfl\r\n\r\n@[simp]\r\nlemma fromColumns_apply_inl (A₁ : Matrix m n₁ R) (A₂ : Matrix m n₂ R) (i : m) (j : n₁) :\r\n    (fromColumns A₁ A₂) i (Sum.inl j) = A₁ i j := rfl\r\n\r\n@[simp]\r\nlemma fromColumns_apply_inr (A₁ : Matrix m n₁ R) (A₂ : Matrix m n₂ R) (i : m) (j : n₂) :\r\n    (fromColumns A₁ A₂) i (Sum.inr j) = A₂ i j := rfl\r\n\r\n@[simp]\r\nlemma toRows₁_apply (A : Matrix (m₁ ⊕ m₂) n R) (i : m₁) (j : n) :\r\n    (toRows₁ A) i j = A (Sum.inl i) j := rfl\r\n\r\n@[simp]\r\nlemma toRows₂_apply (A : Matrix (m₁ ⊕ m₂) n R) (i : m₂) (j : n) :\r\n    (toRows₂ A) i j = A (Sum.inr i) j := rfl\r\n\r\n@[simp]\r\nlemma toRows₁_fromRows  (A₁ : Matrix m₁ n R) (A₂ : Matrix m₂ n R) :\r\n    toRows₁ (fromRows A₁ A₂) = A₁ := rfl\r\n\r\n@[simp]\r\nlemma toRows₂_fromRows  (A₁ : Matrix m₁ n R) (A₂ : Matrix m₂ n R) :\r\n    toRows₂ (fromRows A₁ A₂) = A₂ := rfl\r\n\r\n@[simp]\r\nlemma toColumns₁_apply (A : Matrix m (n₁ ⊕ n₂) R) (i : m) (j : n₁) :\r\n    (toColumns₁ A) i j = A i (Sum.inl j) := rfl\r\n\r\n@[simp]\r\nlemma toColumns₂_apply (A : Matrix m (n₁ ⊕ n₂) R) (i : m) (j : n₂) :\r\n    (toColumns₂ A) i j = A i (Sum.inr j) := rfl\r\n\r\n@[simp]\r\nlemma toColumns₁_fromColumns  (A₁ : Matrix m n₁ R) (A₂ : Matrix m n₂ R) :\r\n    toColumns₁ (fromColumns A₁ A₂) = A₁ := rfl\r\n\r\n@[simp]\r\nlemma toColumns₂_fromColumns  (A₁ : Matrix m n₁ R) (A₂ : Matrix m n₂ R) :\r\n    toColumns₂ (fromColumns A₁ A₂) = A₂ := rfl\r\n\r\n@[simp]\r\nlemma fromColumns_toColumns (A : Matrix m (n₁ ⊕ n₂) R) :\r\n    fromColumns A.toColumns₁ A.toColumns₂ = A := by\r\n  ext i (j | j) <;> simp\r\n\r\n@[simp]\r\nlemma fromRows_toRows (A : Matrix (m₁ ⊕ m₂) n R) : fromRows A.toRows₁ A.toRows₂ = A := by\r\n  ext (i | i) j <;> simp\r\n\r\nlemma fromRows_inj : Function.Injective2 (@fromRows R m₁ m₂ n) := by\r\n  intros x1 x2 y1 y2\r\n  simp only [Function.funext_iff, ← Matrix.ext_iff]\r\n  aesop\r\n\r\nlemma fromColumns_inj : Function.Injective2 (@fromColumns R m n₁ n₂) := by\r\n  intros x1 x2 y1 y2\r\n  simp only [Function.funext_iff, ← Matrix.ext_iff]\r\n  aesop\r\n\r\nlemma fromColumns_ext_iff (A₁ : Matrix m n₁ R) (A₂ : Matrix m n₂ R) (B₁ : Matrix m n₁ R)\r\n    (B₂ : Matrix m n₂ R) :\r\n    fromColumns A₁ A₂ = fromColumns B₁ B₂ ↔ A₁ = B₁ ∧ A₂ = B₂ := fromColumns_inj.eq_iff\r\n\r\nlemma fromRows_ext_iff (A₁ : Matrix m₁ n R) (A₂ : Matrix m₂ n R) (B₁ : Matrix m₁ n R)\r\n    (B₂ : Matrix m₂ n R) :\r\n    fromRows A₁ A₂ = fromRows B₁ B₂ ↔ A₁ = B₁ ∧ A₂ = B₂ := fromRows_inj.eq_iff\r\n```",
                    "createdAt": "2023-08-02T12:05:29Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MZudu",
                    "body": "I did a few steps to streamline the proofs. First, the `simp only` can be a full `simp` without arguments (which is stabler to changes in definitions, and the slowdowns it causes are a lot less in Lean 4). Then we can remove `unfold` because `simp` now has access to enough lemmas. By using the `ext` tactic, we can combine `funext` and `cases`. Instead of `all_goals` I use `<;>` which is slightly more appropriate since the multiple goals come from one tactic. Finally, if any logic needs to be done, we can use `aesop` to do so automatically.\r\n\r\n```suggestion\r\n\r\n/- A column partioned matrix when transposed gives a row partioned matrix with columns of the\r\ninitial matrix tranposed to become rows. -/\r\nlemma transpose_fromColumns (A₁ : Matrix m n₁ R) (A₂ : Matrix m n₂ R) :\r\n    transpose (fromColumns A₁ A₂) = fromRows (transpose A₁) (transpose A₂) := by\r\n  ext (i | i) j <;> simp\r\n\r\n/- A row partioned matrix when transposed gives a column partioned matrix with rows of the initial\r\nmatrix tranposed to become columns. -/\r\nlemma transpose_fromRows (A₁ : Matrix m₁ n R) (A₂ : Matrix m₂ n R) :\r\n    transpose (fromRows A₁ A₂) = fromColumns (transpose A₁) (transpose A₂) := by\r\n  ext i (j | j) <;> simp\r\n```",
                    "createdAt": "2023-08-02T12:08:41Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MZvvF",
                    "body": "```suggestion\r\n\r\n@[simp]\r\nlemma fromRows_mul (A₁ : Matrix m₁ n R) (A₂ : Matrix m₂ n R) (B : Matrix n m R) :\r\n    (fromRows A₁ A₂) ⬝ B = fromRows (A₁ ⬝ B) (A₂ ⬝ B) := by\r\n  ext (_ | _) _ <;> simp [mul_apply]\r\n\r\n@[simp]\r\nlemma mul_fromColumns (A : Matrix m n R) (B₁ : Matrix n n₁ R) (B₂ : Matrix n n₂ R) :\r\n    A ⬝ (fromColumns B₁ B₂) = fromColumns (A ⬝ B₁) (A ⬝ B₂) := by\r\n  ext _ (_ | _) <;> simp [mul_apply]\r\n\r\n@[simp]\r\nlemma fromRows_zero : fromRows (0 : Matrix m₁ n R) (0 : Matrix m₂ n R) = 0 := by\r\n  ext (_ | _) _ <;> simp\r\n\r\n@[simp]\r\nlemma fromColumns_zero : fromColumns (0 : Matrix m n₁ R) (0 : Matrix m n₂ R) = 0 := by\r\n  ext _ (_ | _) <;> simp\r\n\r\n@[simp]\r\nlemma fromColumns_fromRows_eq_fromBlocks (B₁₁ : Matrix m₁ n₁ R) (B₁₂ : Matrix m₁ n₂ R)\r\n    (B₂₁ : Matrix m₂ n₁ R) (B₂₂ : Matrix m₂ n₂ R) :\r\n    fromColumns (fromRows B₁₁ B₂₁) (fromRows B₁₂ B₂₂) = fromBlocks B₁₁ B₁₂ B₂₁ B₂₂ := by\r\n  ext (_ | _) (_ | _) <;> simp\r\n\r\n@[simp]\r\nlemma fromRows_fromColumn_eq_fromBlocks (B₁₁ : Matrix m₁ n₁ R) (B₁₂ : Matrix m₁ n₂ R)\r\n    (B₂₁ : Matrix m₂ n₁ R) (B₂₂ : Matrix m₂ n₂ R) :\r\n    fromRows (fromColumns B₁₁ B₁₂) (fromColumns B₂₁ B₂₂) = fromBlocks B₁₁ B₁₂ B₂₁ B₂₂ := by\r\n  ext (_ | _) (_ | _) <;> simp\r\n\r\n/-- A row partitioned matrix multiplied by a column partioned matrix gives a 2 by 2 block matrix -/\r\nlemma fromRows_mul_fromColumns (A₁ : Matrix m₁ n R) (A₂ : Matrix m₂ n R)\r\n    (B₁ : Matrix n n₁ R) (B₂ : Matrix n n₂ R) :\r\n    (fromRows A₁ A₂) ⬝ (fromColumns B₁ B₂) =\r\n      fromBlocks (A₁ ⬝ B₁) (A₁ ⬝ B₂) (A₂ ⬝ B₁) (A₂ ⬝ B₂) := by\r\n  ext (_ | _) (_ | _) <;> simp\r\n\r\n/-- A column partitioned matrix mulitplied by a row partitioned matrix gives the sum of the \"outer\"\r\nproducts of the block matrices -/\r\nlemma fromColumns_mul_fromRows (A₁ : Matrix m n₁ R) (A₂ : Matrix m n₂ R)\r\n    (B₁ : Matrix n₁ n R) (B₂ : Matrix n₂ n R) :\r\n    fromColumns A₁ A₂ ⬝ fromRows B₁ B₂ = (A₁ ⬝ B₁ + A₂ ⬝ B₂) := by\r\n  ext\r\n  simp [mul_apply]\r\n\r\n/-- A column partitioned matrix multipiled by a block matrix results in a column partioned matrix -/\r\nlemma fromColumns_mul_fromBlocks (A₁ : Matrix m m₁ R) (A₂ : Matrix m m₂ R)\r\n    (B₁₁ : Matrix m₁ n₁ R) (B₁₂ : Matrix m₁ n₂ R) (B₂₁ : Matrix m₂ n₁ R) (B₂₂ : Matrix m₂ n₂ R) :\r\n    (fromColumns A₁ A₂) ⬝ fromBlocks B₁₁ B₁₂ B₂₁ B₂₂ =\r\n      fromColumns (A₁ ⬝ B₁₁ + A₂ ⬝ B₂₁) (A₁ ⬝ B₁₂ + A₂ ⬝ B₂₂) := by\r\n  ext _ (_ | _) <;> simp [mul_apply]\r\n\r\n/-- A block matrix mulitplied by a row partitioned matrix gives a row partitioned matrix -/\r\nlemma fromBlocks_mul_fromRows (A₁ : Matrix n₁ n R) (A₂ : Matrix n₂ n R)\r\n    (B₁₁ : Matrix m₁ n₁ R) (B₁₂ : Matrix m₁ n₂ R) (B₂₁ : Matrix m₂ n₁ R) (B₂₂ : Matrix m₂ n₂ R) :\r\n    fromBlocks B₁₁ B₁₂ B₂₁ B₂₂ ⬝ (fromRows A₁ A₂) =\r\n      fromRows (B₁₁ ⬝ A₁ + B₁₂ ⬝ A₂) (B₂₁ ⬝ A₁ + B₂₂ ⬝ A₂) := by\r\n  ext (_ | _) _ <;> simp [mul_apply]\r\n```",
                    "createdAt": "2023-08-02T12:12:30Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MZ4U6",
                    "body": "I tried to restructure the proof to emphasise `mul_eq_one_comm` and then rewrite both sides so they'd resemble this. I came up with the following:\r\n```suggestion\r\n  calc fromColumns A₁ A₂ ⬝ fromRows B₁ B₂ = 1\r\n  _ ↔ submatrix (fromColumns A₁ A₂) id e ⬝ submatrix (fromRows B₁ B₂) e id = 1 := by\r\n    simp\r\n  _ ↔ submatrix (fromRows B₁ B₂) e id ⬝ submatrix (fromColumns A₁ A₂) id e = 1 :=\r\n    mul_eq_one_comm\r\n  _ ↔ reindex e.symm e.symm (fromRows B₁ B₂ ⬝ fromColumns A₁ A₂) = reindex e.symm e.symm 1 := by\r\n    simp only [reindex_apply, Equiv.symm_symm, submatrix_one_equiv,\r\n        submatrix_mul (he₂ := Function.bijective_id)]\r\n  _ ↔ fromRows B₁ B₂ ⬝ fromColumns A₁ A₂ = 1 :=\r\n    (reindex _ _).injective.eq_iff\r\n```",
                    "createdAt": "2023-08-02T12:45:01Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5MZ4ir",
                    "body": "```suggestion\r\n\r\n/- A column partioned matrix in a Star ring when conjugate transposed gives a row partitioned matrix\r\nwith the columns of the initial matrix conjugate transposed to become rows. -/\r\nlemma conjTranspose_fromColumns_eq_fromRows_conjTranspose (A₁ : Matrix m n₁ R)\r\n    (A₂ : Matrix m n₂ R) :\r\n    conjTranspose (fromColumns A₁ A₂) = fromRows (conjTranspose A₁) (conjTranspose A₂) := by\r\n  ext (_ | _) _ <;> simp\r\n\r\n/- A row partioned matrix in a Star ring when conjugate transposed gives a column partitioned matrix\r\nwith the rows of the initial matrix conjugate transposed to become columns. -/\r\nlemma conjTranspose_fromRows_eq_fromColumns_conjTranspose (A₁ : Matrix m₁ n R)\r\n    (A₂ : Matrix m₂ n R) : conjTranspose (fromRows A₁ A₂) =\r\n      fromColumns (conjTranspose A₁) (conjTranspose A₂) := by\r\n  ext _ (_ | _) <;> simp\r\n```",
                    "createdAt": "2023-08-02T12:45:47Z",
                    "author": {
                      "login": "Vierkantor"
                    }
                  }
                ]
              }
            }
          ]
        },
        "closingIssuesReferences": {
          "nodes": []
        },
        "participants": {
          "nodes": [
            {
              "id": "MDQ6VXNlcjYwNjAxMzY=",
              "login": "MohanadAhmed"
            },
            {
              "id": "MDQ6VXNlcjIxMTY1NzA=",
              "login": "Vierkantor"
            },
            {
              "id": "U_kgDOB75MNQ",
              "login": "leanprover-community-mathlib4-bot"
            }
          ]
        },
        "state": "CLOSED",
        "statusCheckRollup": null,
        "title": "[Merged by Bors] - feat: column and row partitioned matrices",
        "updatedAt": "2023-08-02T14:42:28Z",
        "url": "https://github.com/leanprover-community/mathlib4/pull/6052",
        "timelineItems": {
          "nodes": [
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "b53a0fc73eecb522e47d976d8d5a8439a1cf5a6f"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "7a97815639607510bc7c01231cf310c6b64b8b87"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "3ff666859f19446688642d7f22081aead5b4e35f"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "0dcd71ff3d7a0a8e598c6796e50f2ba0cb6611c0"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5sRdIpzwAAAAJNf7m3",
              "createdAt": "2023-07-22T02:54:18Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "RenamedTitleEvent"
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "b89c64e53e99800d6de7fb8d9cd177b9c7974a9f"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "67db35c6be53e4f9f22060f3c68d11afb1a72d4f"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "1c30cf66c9482a9d127f0c7ff185fbc226d8ed5d"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "3748436b5f7aa79d87d67907fa11381b8177bcf5"
              }
            },
            {
              "__typename": "ReviewRequestedEvent",
              "id": "RRE_lADOFcwZ1c5sRdIpzwAAAAJQNqoU",
              "createdAt": "2023-07-27T13:11:58Z",
              "requestedReviewer": {
                "id": "MDQ6VXNlcjIxMTY1NzA=",
                "login": "Vierkantor"
              }
            },
            {
              "__typename": "AssignedEvent",
              "id": "AE_lADOFcwZ1c5sRdIpzwAAAAJQ1HpH",
              "createdAt": "2023-07-28T09:29:22Z",
              "assignee": {
                "id": "MDQ6VXNlcjIxMTY1NzA=",
                "login": "Vierkantor"
              }
            },
            {
              "__typename": "RenamedTitleEvent"
            },
            {
              "__typename": "PullRequestReview",
              "id": "PRR_kwDOFcwZ1c5cqSQX",
              "createdAt": "2023-07-31T11:50:54Z",
              "body": "Sorry for taking a while to get around to your review. Overall I like the structure of your work, there are just a few things that we need to fill in and clean up.\r\n\r\nI propose some extra lemmas that will noticeably change your proofs, so I will look at the style of proofs next time.",
              "author": {
                "login": "Vierkantor"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5sRdIpzwAAAAJR2mn8",
              "createdAt": "2023-07-31T12:20:50Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5sRdIpzwAAAAJR2moG",
              "createdAt": "2023-07-31T12:20:50Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7P265b",
                "name": "awaiting-author"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5sRdIpzwAAAAJR2moO",
              "createdAt": "2023-07-31T12:20:50Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABViJjTQ",
                "name": "t-algebra"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "e8acb783efa8d1ad9f25374444bef8db09d1731f"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "6c62d95e8a4dd34dcd43dc28b1ad896b101b1d31"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "1c674727875f90b7bb51e1ee24d5b0a27d8685da"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "50f9ecb22593e3b17e4bb098f6d6f5691b04209b"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5sRdIpzwAAAAJSFDsE",
              "createdAt": "2023-07-31T17:41:35Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7P265b",
                "name": "awaiting-author"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5sRdIpzwAAAAJSFDsQ",
              "createdAt": "2023-07-31T17:41:35Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "943961a42327000fbe5c87972448c2fde5d53f87"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5sRdIpzwAAAAJSoksE",
              "createdAt": "2023-08-01T13:00:01Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABKteTVQ",
                "name": "awaiting-CI"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5sRdIpzwAAAAJSprEs",
              "createdAt": "2023-08-01T13:23:23Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABKteTVQ",
                "name": "awaiting-CI"
              }
            },
            {
              "__typename": "PullRequestReview",
              "id": "PRR_kwDOFcwZ1c5c6j5y",
              "createdAt": "2023-08-02T12:05:29Z",
              "body": "I went through and cleaned up the proofs. If you're happy with the changes, then this looks ready to me.\r\n\r\nThanks!\r\n\r\nbors d+",
              "author": {
                "login": "Vierkantor"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5jElr8",
              "createdAt": "2023-08-02T12:46:24Z",
              "body": ":v: MohanadAhmed can now approve this pull request. To approve and merge a pull request, simply reply with `bors r+`. More detailed instructions are available [here](https://bors.tech/documentation/getting-started/#reviewing-pull-requests).",
              "author": {
                "login": "bors"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5sRdIpzwAAAAJTUHSR",
              "createdAt": "2023-08-02T12:46:36Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABAt13Ow",
                "name": "delegated"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5sRdIpzwAAAAJTUHUo",
              "createdAt": "2023-08-02T12:46:37Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "PullRequestCommit",
              "commit": {
                "oid": "51275ea27ccc42a2895510d3bbd8304715f321b0"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5jE0fi",
              "createdAt": "2023-08-02T13:24:05Z",
              "body": "> ✌️ MohanadAhmed can now approve this pull request. To approve and merge a pull request, simply reply with `bors r+`. More detailed instructions are available [here](https://bors.tech/documentation/getting-started/#reviewing-pull-requests).\r\n\r\nbors r+",
              "author": {
                "login": "MohanadAhmed"
              }
            },
            {
              "__typename": "ReferencedEvent"
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5jFVBs",
              "createdAt": "2023-08-02T14:42:21Z",
              "body": "Pull request successfully merged into master.\n\n  Build succeeded!\n\n  The publicly hosted instance of bors-ng is deprecated and will go away soon.\n\n  If you want to self-host your own instance, [instructions are here][instructions].\n  For more help, visit [the forum].\n\n  If you want to switch to GitHub's built-in merge queue, visit [their help page][gh].\n\n  [instructions]: https://github.com/bors-ng/bors-ng#how-to-set-up-your-own-real-instance\n  [the forum]: https://forum.bors.tech\n  [gh]: https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue\n\n\n\n  * [Build](https://github.com/leanprover-community/mathlib4/actions/runs/5739595642/job/15555540731)\n  * [Check all files imported](https://github.com/leanprover-community/mathlib4/actions/runs/5739595642/job/15555541085)\n  * [Lint style](https://github.com/leanprover-community/mathlib4/actions/runs/5739595642/job/15555541622)",
              "author": {
                "login": "bors"
              }
            },
            {
              "__typename": "RenamedTitleEvent"
            },
            {
              "__typename": "ClosedEvent",
              "id": "CE_lADOFcwZ1c5sRdIpzwAAAAJTZI9C",
              "createdAt": "2023-08-02T14:42:23Z"
            },
            {
              "__typename": "HeadRefDeletedEvent",
              "id": "HRDE_lADOFcwZ1c5sRdIpzwAAAAJTZJJX",
              "createdAt": "2023-08-02T14:42:28Z"
            },
            {
              "__typename": "ReferencedEvent"
            },
            {
              "__typename": "ReferencedEvent"
            },
            {
              "__typename": "ReferencedEvent"
            },
            {
              "__typename": "CrossReferencedEvent",
              "id": "CRE_kwDOFcwZ1c5Oh_s4",
              "createdAt": "2023-09-21T22:28:02Z",
              "source": {
                "id": "I_kwDOFcwZ1c5xOvHv",
                "title": "Linter / Formatter Wishlist",
                "url": "https://github.com/leanprover-community/mathlib4/issues/7217"
              }
            }
          ]
        }
      }
    }
  }
}
