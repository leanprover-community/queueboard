{
  "data": {
    "repository": {
      "pullRequest": {
        "additions": 165,
        "assignees": {
          "nodes": [
            {
              "id": "MDQ6VXNlcjQ4NjU2Nzkz",
              "login": "ADedecker"
            }
          ]
        },
        "author": {
          "login": "grunweg"
        },
        "autoMergeRequest": null,
        "baseRefName": "master",
        "body": "A topological manifold has no canonical measure, but there is a canonical notion of measure zero subsets.\r\n\r\nWe show that these are closed under subsets and countable unions (hence define a filter, the almost everywhere filter)\r\nand that a closed nowhere dense has empty interior.\r\n\r\nThis is necessary for stating the general version of Sard's theorem (in finite dimensions), and a first step towards its proof.\r\n\r\n\r\nThis code was written at LftCM 2023. Thanks for @fpvandoorn for mentoring me! :heart:\r\n\r\n---\r\nUnresolved questions/looking for feedback\r\n- Is \"measure zero\" a good name or would \"null set\" be better? I tend towards the former, but welcome input from a measure theorist (which I'm not).\r\n- What is the correct definition? One could also define \"measure zero\" using any `IsOpenPosMeasure` on the charted space.\r\nI think all results in this file still hold then, but for applications (e.g., Sard's theorem), this might be too general.\r\n- define custom notation, similar to the a.e. filter on a measure space? (We could include $J$ instead of $\\mu$.)\r\n- what's the right syntax for formulas in docstrings --- use LaTeX or backticks? I don't know how to preview the generated docs, the guidelines are a bit ambiguous for me.\r\n",
        "changedFiles": 3,
        "closed": false,
        "closedAt": null,
        "comments": {
          "nodes": [
            {
              "id": "IC_kwDOFcwZ1c5mFmC3",
              "body": "awaiting-review",
              "createdAt": "2023-09-10T07:51:29Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mFmZK",
              "body": "Sorry for the churn while trying to fix the .bib file. (Is there a way to apply the suggested fix automatically? I have biber, but not bibtool installed locally.) Edit: I'm giving up; I don't understand the new error. Can a kind soul help me, please?",
              "createdAt": "2023-09-10T07:58:36Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mF6Qu",
              "body": ".bib file is fixed now; the build lints.",
              "createdAt": "2023-09-10T14:12:23Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mF-_v",
              "body": "I have a few mathematical suggestions/options/random thoughts. They don't necessarily have to be taken into account for this PR, but I want to at least discuss them with you and @fpvandoorn (in fact you may have discussed some of them already in person). Disclaimer: I'm neither a geometer nor a measure theorist, but I'm a filter enthusiast :grin: \r\n\r\nRegarding which measure to consider, here are three natural options that come to my mind:\r\n1. You could pick a measure `μ` on the model space `E` and use that everywhere.\r\n2. If choosing a measure is too much, maybe it's better to choose a filter (probably with countable intersection) of declared co-null sets on the model space. \r\n3. Even if you want to only consider Haar measures, I think it's better to first define the filter of co-negligible sets for all/any Haar measure on the model space, and then move to manifolds. I think separating the two steps could make your life easier, for example showing that you only have to check *one* Haar measure will trivially follow from the case of the model space. I'm not sure if I'm clear here, feel free to ask for details :sweat_smile: \r\n\r\nThen, assuming you've fixed a filter `F` of co-null sets on your model space (either by 1., 2., or 3.), I think you can construct the `ae` filter directly as `⨆ e ∈ atlas H M, (comap (I ∘ e) F) ⊓ 𝓟 e.source`. I haven't tested it in Lean, but I'm pretty sure you recover your definition by using [Filter.mem_iSup](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.mem_iSup), [Filter.mem_inf_principal'](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.mem_inf_principal') and [Filter.compl_mem_comap](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.compl_mem_comap). I claim that this is, at least morally, the right way to define it, and then you can work with this filter as much as possible (in particular, being a null set is the same as being eventually equal to the empty set for this filter). \r\n\r\nRegarding notation, one possibility (definitely not in scope for this PR) would be to define an intermediate between `MeasurableSpace` and `MeasureSpace` where you don't have the measure yet but you know which sets are negligible. This would work well with option 2. above, but this would be a big refactor and I'm not sure how useful it is.",
              "createdAt": "2023-09-10T15:35:53Z",
              "author": {
                "login": "ADedecker"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mF_bu",
              "body": "By the way, do you know of any case where the measure(s) you'd want to consider live on the model space (as opposed to the model vector space)?",
              "createdAt": "2023-09-10T15:43:37Z",
              "author": {
                "login": "ADedecker"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mGQRQ",
              "body": "Force-pushed: addressed review nits and squashed commits a little. No further changes.",
              "createdAt": "2023-09-10T19:19:29Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mGQ55",
              "body": "> By the way, do you know of any case where the measure(s) you'd want to consider live on the model space (as opposed to the model vector space)?\r\n\r\nI'm not fully sure if I'm answering *your* question --- but here goes.\r\nIn general, you care quite a bit about Sard's theorem for manifolds with boundary. One cute application is Hirsch's proof of the Brouwer fixed point theorem --- using Sard's theorem, for a hypothetical retraction $D^n\\to S^{n-1}$. More deeply, the Transversality Theorem (\"transversality is generic\") uses Sard's theorem for the local argument (and a globalisation procedure).\r\nMy definition currently excluded manifolds with boundary, for the reason mentioned in the TODO --- Floris and I presumed the current definition is simply too weak.\r\n\r\nI haven't thought much about whether I'd define measure zero using the model space or the vector space behind it.",
              "createdAt": "2023-09-10T19:32:10Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mGRfc",
              "body": "> > By the way, do you know of any case where the measure(s) you'd want to consider live on the model space (as opposed to the model vector space)?\r\n> \r\n> I'm not fully sure if I'm answering _your_ question --- but here goes. In general, you care quite a bit about Sard's theorem for manifolds with boundary. One cute application is Hirsch's proof of the Brouwer fixed point theorem --- using Sard's theorem, for a hypothetical retraction Dn→Sn−1. More deeply, the Transversality Theorem (\"transversality is generic\") uses Sard's theorem for the local argument (and a globalisation procedure). My definition currently excluded manifolds with boundary, for the reason mentioned in the TODO --- Floris and I presumed the current definition is simply too weak.\r\n> \r\n> I haven't thought much about whether I'd define measure zero using the model space or the vector space behind it.\r\n\r\nThinking about this some more: I personally only care about the Haar/Lebesgue measure on (spaces isomorphic to) $\\mathbb{R}^n$. These restrict to the canonical model spaces, but naturally live on the model vector space. I'm not aware of gaining anything by considering measures on the model spaces.",
              "createdAt": "2023-09-10T19:42:08Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mGSWu",
              "body": "> I have a few mathematical suggestions/options/random thoughts. They don't necessarily have to be taken into account for this PR, but I want to at least discuss them with you and @fpvandoorn (in fact you may have discussed some of them already in person). Disclaimer: I'm neither a geometer nor a measure theorist, but I'm a filter enthusiast 😁\r\n> \r\n> Regarding which measure to consider, here are three natural options that come to my mind:\r\n> \r\n>     1. You could pick a measure `μ` on the model space `E` and use that everywhere.\r\n> \r\n>     2. If choosing a measure is too much, maybe it's better to choose a filter (probably with countable intersection) of declared co-null sets on the model space.\r\n> \r\n>     3. Even if you want to only consider Haar measures, I think it's better to first define the filter of co-negligible sets for all/any Haar measure on the model space, and then move to manifolds. I think separating the two steps could make your life easier, for example showing that you only have to check _one_ Haar measure will trivially follow from the case of the model space. I'm not sure if I'm clear here, feel free to ask for details 😅\r\n> \r\n> \r\n> Then, assuming you've fixed a filter `F` of co-null sets on your model space (either by 1., 2., or 3.), I think you can construct the `ae` filter directly as `⨆ e ∈ atlas H M, (comap (I ∘ e) F) ⊓ 𝓟 e.source`. I haven't tested it in Lean, but I'm pretty sure you recover your definition by using [Filter.mem_iSup](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.mem_iSup), [Filter.mem_inf_principal'](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.mem_inf_principal') and [Filter.compl_mem_comap](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.compl_mem_comap). I claim that this is, at least morally, the right way to define it, and then you can work with this filter as much as possible (in particular, being a null set is the same as being eventually equal to the empty set for this filter).\r\n> \r\n> Regarding notation, one possibility (definitely not in scope for this PR) would be to define an intermediate between `MeasurableSpace` and `MeasureSpace` where you don't have the measure yet but you know which sets are negligible. This would work well with option 2. above, but this would be a big refactor and I'm not sure how useful it is.\r\n\r\nThanks for the fast response! These are interesting suggestions, I definitely hadn't thought about this before.\r\n\r\nFor me, it's important that the notion of measure zero sets is independent of auxiliary choices. (Sard's theorem doesn't mention any such choices, for instance.) Choosing a measure on the model space or model vector space induces a measure on the manifold --- but not canonically so. (Extending from each model space to the whole manifold needs a partition of unity, I believe --- which is very far from canonical. And you might have several measures on the model space to choose from. Let alone the fact that to me, the choice of model space (among isomorphic representatives) is not canonical either, and not what the manifold is really about. In other words, depending on that also doesn't feel natural to me.)\r\n\r\nIn effect, the resulting concept is either not canonical, or one needs to argue that all these choices yield the same result. My definition is this equivalent result.\r\n\r\nI haven't yet thought much about whether your approach would yield simpler *proofs*. (I only learned about filters last Wednesday - I think they're cool, but I'm not very *used* to them yet.) If you use filter, you also have to show independence of auxiliary choices; I'm not sure how much extra work that entails.\r\n",
              "createdAt": "2023-09-10T19:59:45Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mGSZp",
              "body": "Actually, I just wondered if measure zero sets are actually the canonical concept to consider. After all, for Sard's theorem in infinite dimensions (maps between Banach manifolds), the set of critical values is a meagre set --- there's no useful notion of \"measure zero\" any more. The right version of Sard's theorem in finite dimensions also goes in these terms, the critical set is meagre.\r\n\r\nThat said, measure zero sets are still used in the proof. (While in general, none of meagreness and measure zero implies the other, in a Baire space a $\\sigma$-compact measure zero set is meagre. The standard proof shows that the critical set has measure zero. It is also $\\sigma$-compact (the critical values are closed and the domain $M$ is $\\sigma$-compact), hence is meagre.\r\n\r\n\r\nThat is to say: I do think this definition is necessary for proving Sard's theorem. But a next step would be showing the implication above \"in a Baire space, a $\\sigma$-compact measure zero set is meagre\". (I haven't checked to what degree this is in mathlib already.)\r\n",
              "createdAt": "2023-09-10T20:00:37Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mXgr3",
              "body": "I agree that choosing a measure on the model space doesn't feel right. Note however that I didn't want to use it to construct a measure on the manifold, just to have a simpler definition of measure zero. \r\n\r\n> In effect, the resulting concept is either not canonical, or one needs to argue that all these choices yield the same result. My definition is this equivalent result.\r\n\r\nNote that, while this is morally true, this doesn't mean that you have less work to do: at some point you will still want to show that actually, testing measure zero for *all* measures or for *one* given Haar measure is the same, and the proof of that will essentially be what would have to be done to prove that the definition \"with a choice\" is actually independent from the choice. \r\n\r\n> I haven't yet thought much about whether your approach would yield simpler proofs. (I only learned about filters last Wednesday - I think they're cool, but I'm not very used to them yet.) If you use filter, you also have to show independence of auxiliary choices; I'm not sure how much extra work that entails.\r\n\r\nThe definition I proposed using filters doesn't need extra choices in itself, all the choices happen in the choice of the filter `F` on the model space (which will simplify the proof of the result I wrote just above). I'm happy to rule out `μ.ae` for a specific `μ`, but that could be `⨆ (μ : Measure E) [IsAddHaarMeasure μ], μ.ae`, which would give out exactly your definition, without making any additional choice. \r\nMy claim is that, on top of potentially simplifying the proof, the `ae` filter on the manifold is the natural object here, because it is precisely what's needed to encode \"P(x) is true for almost every x\", and \"S has measure zero\" is just the special case \"For almost every x, x is not in S\". Does that make sense? Another example is precisely Sard's theorem, which could be stated as \"almost all points in the codomain are regular values for f\" which would be more natural to work with (thanks to the extensive filter API) than the usual \"the set of critical values has measure zero\". \r\n\r\nRegarding using meagre sets, I think the notion of measure zero definitely deserves to exist in some form, independently of meagre sets. By the way, note that we have the same kind of filter for co-meagre sets, see [eventually_residual](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/MetricSpace/Baire.html#eventually_residual).",
              "createdAt": "2023-09-13T11:22:29Z",
              "author": {
                "login": "ADedecker"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mXrom",
              "body": "I have a mathematical problem with the current definition: there *is no* canonical notion of measure zero on a topological manifold, as homeomorphisms don't respect the Lebesgue measure class in general. You need a C^1 manifold to get a meaningful notion, so in mathlib we would probably require a smooth manifold for simplicity. In this setting, you have partitions of unity, so you can construct *a* Lebesgue measure. And it is often important to have a Lebesgue measure at our disposal, so why not first construct such a Lebesgue measure and then define measure zero with respect to this measure?",
              "createdAt": "2023-09-13T11:55:16Z",
              "author": {
                "login": "sgouezel"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5ma7Dq",
              "body": "Thanks for the detailed comments, @ADedecker @sgouezel! Let me respond to two points already; I'll have to ponder the others more deeply. (Given that you're suggesting different approaches, I want to, at least, make up my mind :smiley:)\r\n\r\n> I have a mathematical problem with the current definition: there _is no_ canonical notion of measure zero on a topological manifold, as homeomorphisms don't respect the Lebesgue measure class in general. You need a C^1 manifold to get a meaningful notion, so in mathlib we would probably require a smooth manifold for simplicity.\r\n\r\nVery good point, you're right. While the current definition can be *stated* for topological manifolds, it only makes sense for C¹ manifolds. (I thought about the C¹ aspect, but didn't connect the dots...)\r\n\r\n-------\r\n\r\nI also agree that the notion of \"almost everywhere\" is the conceptually useful one. (Sard's theorem, or the transversality theorem, are theorems about generic properties after all.) I would argue that the complementary notion still should be stated: for instance, the proof of Sard's theorem uses that measure zero sets are closed under countable unions. I wouldn't mind, though, proving all properties of measure zero sets by dualizing the results for the a.e. notion.\r\n",
              "createdAt": "2023-09-13T21:21:43Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5mgdIs",
              "body": "Let me summarize. My impression is that we all agree the statements in the PR (measure zero sets on a manifold generate a filter, which is closed under countable intersections) are worthwhile, we're just discussing the best way to prove them.\r\n\r\n@sgouezel If I understand correctly, you suggest to\r\n- define a Lebesgue measure on each $C^1$ (e.g., smooth) manifold by pulling back the Lebesgue measure on each chart and using a partition of unity\r\n- show that if $\\mu$ and $\\mu'$ are two such Lebesgue measure, we have $\\mu(A)=0$ iff $\\mu'(A)=0$. (This uses that C¹ maps are locally Lipschitz and those preserve measure zero sets.)\r\n- define measure zero sets as null sets w.r.t. any (or equivalently, all) Lebesgue measure(s) on $M$.\r\n- deduce: $A\\subseteq M$ has measure zero iff $\\phi(U\\cap A)$ has measure zero (w.r.t. the Haar measure), for each chart $(\\phi,U)$ of $M$\r\n- the countable intersection filter is then a special case of the a.e. filter on a general measure space.\r\n\r\n@ADedecker As I understand I, you suggest a different description of the a.e. filter on $M$: choose an a.e. filter on the model space $F$ (or even a measure) and define the a.e. filter on `M` using that. (The a.e. filter for the Haar measure should be canonical, as the Haar measure on Euclidean space is unique up to a multiplicative constant. Neat!)\r\n\r\nIt seems to me these ideas are complementary, and having both would certainly be worthwhile.\r\n\r\n------\r\n\r\nIn all applications I know (using Sard's theorem), measure zero sets are never used \"constructively\": you care that a particular property is generic, but you never need to know (nor care) if a *particular* set has measure zero. (I can imagine some applications care about this.) Making this definition more workable by relating to the Lebesgue measure is not a priority for me personally; yet, this is certainly useful and belongs to mathlib.\r\n\r\nI'm unsure of the best way forward. My lean time in the next few months is rather limited; I'm not sure if I have the capacity to redo the proof as above *soon*. (I do intend to eventually return to this for sure!)\r\n\r\nWriting down the Lebesgue measure definition is not too hard, I guess. I have in-progress code for parenthetical in point 2 (needing some review, but perhaps I can finish that/push here). I cannot estimate the amount of work necessary for the filters approach.",
              "createdAt": "2023-09-14T16:35:43Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5nMJd7",
              "body": "**Status update.** I intend to focus on finishing my PhD thesis in the next months, hence will put this aside for now. (I intend to return to it.) Help is welcome. \r\n\r\nNext steps, as I see them.\r\n1. Define Lebesgue measure on a C¹ manifold (pull back Lebesgue measure on each chart, use a partition of unity).\r\n2. Re-define: a measure zero subset of a manifold is a null set w.r.t. one (or any) Lebesgue measure.\r\n3. Show step 2 is well-defined: null sets on $\\mathbb{R}^n$ are preserved by coordinate changes.\r\n4. Show: $A \\subseteq M$$ has measure zero iff for each chart $(\\phi,U)$, the set $\\phi(U\\cap A)$ is a null set.\r\n5. Define the almost everywhere filter on a manifold, show it's a `CountableIntersectionFilter`.\r\n5. Show the ae filter is induced from the ae filter on the charts.\r\n\r\nI have worked towards step 3: a more conceptual version holds for locally Lipschitz maps metric metric spaces.\r\n- #7314 defines locally Lipschitz maps (and shows C¹ maps are locally Lipschitz)\r\n- I [have proven](https://github.com/fpvandoorn/sard/blob/master/Sard/LocallyLipschitzMeasureZero.lean) that locally Lipschitz maps preserve measure zero sets. (A version on an open set is almost done.)\r\n- In fact, mathlib has most of this already, via `ContDiffOn.dimH_image_le`.",
              "createdAt": "2023-09-22T11:09:37Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5x5QBp",
              "body": "A few months later, I'd like to move this forward again. In the above, I see requests to\r\n- define a Lebesgue measure on (finite-dimensional) manifolds and define measure zero sets this way\r\n(then deducing the equivalence to the current definition)\r\n- write the almost everywhere filter in terms of the filter in charts\r\n\r\nI'm ready to do (1), but there is one catch: constructing Lebesgue measure on a manifold commonly proceeds using Riemannian metrics. (For instance, as \"for each Riemannian metric on M, there's a corresponding Lebesgue measure\" and showing that measure zero sets are independent of this choice.) As I understand it, however, Riemannian metrics are still some way off, in the sense that @hrmacbeth has a definition written down which is not suitable for entering mathlib yet.\r\n\r\nMore generally, that seems like a phenomenal expansion of this PR's scope, as it would entail\r\n1. defining oriented atlasses and orientations of a finite-dimensional manifold\r\n2. some definition of Riemannian metric\r\n(yes, there is a theory of sprays for Banach manifolds: perhaps we can restrict to finite-dimensional manifolds for now)\r\n3. showing finite-dimensional smooth manifolds admit a Riemannian metric\r\n4. use that to define a Lebesgue measure\r\n5. show there is a unique Lebesgue measure, given a Riemannian metric\r\nAll of this is good and useful work, but need it block this PR?\r\n\r\nIs there some middle ground: for instance, by\r\n- defining continuous Riemannian metrics for now\r\n(upgrading this to smooth can happen when the kinks with smooth vector bundles are ironed out)\r\n- defining the Lebesgue measure\r\n- showing that a set has measure zero iff each image in charts has; this also shows independence of the chosen measure\r\n\r\n@sgouezel I would be interested in your opinion here.",
              "createdAt": "2024-01-25T19:18:55Z",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "id": "IC_kwDOFcwZ1c5x5cYd",
              "body": "Sorry for the force-push: I just squashed the previous commits, merged master and made a new commit golfing things.\r\nGiven that my understanding is this won't be merged as-is anyway, I felt fine with this.",
              "createdAt": "2024-01-25T19:47:44Z",
              "author": {
                "login": "grunweg"
              }
            }
          ]
        },
        "commits": {
          "nodes": [
            {
              "commit": {
                "oid": "b0ad82edf5e39826b6b6a0db01cda06bd3029aa7",
                "additions": 179,
                "deletions": 0,
                "committedDate": "2024-01-25T19:29:56Z",
                "author": {
                  "name": "Michael Rothgang",
                  "email": "rothgami@math.hu-berlin.de"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "0f77ea57529f8b2be42dce7d56bb9f644892d277",
                "additions": 14,
                "deletions": 15,
                "committedDate": "2024-01-25T19:29:56Z",
                "author": {
                  "name": "Michael Rothgang",
                  "email": "rothgami@math.hu-berlin.de"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "391e538ad6a3394811f153529a56be5346f70568",
                "additions": 9,
                "deletions": 10,
                "committedDate": "2024-01-25T19:29:56Z",
                "author": {
                  "name": "Michael Rothgang",
                  "email": "rothgami@math.hu-berlin.de"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "cb930f555552fc660000106559f7524e484e4cfd",
                "additions": 210651,
                "deletions": 106049,
                "committedDate": "2024-01-25T19:30:23Z",
                "author": {
                  "name": "Michael Rothgang",
                  "email": "rothgami@math.hu-berlin.de"
                },
                "statusCheckRollup": null
              }
            },
            {
              "commit": {
                "oid": "6c678696eca6298971fff07181192e24056fcb5e",
                "additions": 16,
                "deletions": 28,
                "committedDate": "2024-01-25T19:40:33Z",
                "author": {
                  "name": "Michael Rothgang",
                  "email": "rothgami@math.hu-berlin.de"
                },
                "statusCheckRollup": {
                  "contexts": {
                    "nodes": [
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDzoQ",
                        "name": "Add annotations",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616591/job/20875113377"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDwxg",
                        "name": "Cancel Previous Runs (CI)",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875112646"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3ED0Iw",
                        "name": "Cancel Previous Runs (CI)",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875113507"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3ED0bw",
                        "name": "Lint style",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616587/job/20875113583"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3ED0Lg",
                        "name": "Lint style (fork)",
                        "conclusion": "SKIPPED",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875113518"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDyaA",
                        "name": "Lint style",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875113064"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDzrA",
                        "name": "Check all files imported",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616587/job/20875113388"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDxig",
                        "name": "Check all files imported (fork)",
                        "conclusion": "SKIPPED",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875112842"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDwxQ",
                        "name": "Check all files imported",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875112645"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDzEA",
                        "name": "check workflows (fork)",
                        "conclusion": "SKIPPED",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875113232"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDxhw",
                        "name": "check workflows",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875112839"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDyYA",
                        "name": "Build (fork)",
                        "conclusion": "SKIPPED",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875113056"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3EDzMA",
                        "name": "Build",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875113264"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3ED1Dg",
                        "name": "Post-CI job (fork)",
                        "conclusion": "SKIPPED",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875113742"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAE3E2Umg",
                        "name": "Post-CI job",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875941018"
                      },
                      {
                        "__typename": "CheckRun",
                        "id": "CR_kwDOFcwZ1c8AAAAFLZaoFQ",
                        "name": "Summary",
                        "conclusion": "SUCCESS",
                        "status": "COMPLETED",
                        "detailsUrl": "https://dashboard.mergify.com/github/leanprover-community/repo/mathlib4/event-logs?pullRequestNumber=7076"
                      }
                    ]
                  }
                }
              }
            }
          ]
        },
        "createdAt": "2023-09-10T07:50:31Z",
        "deletions": 0,
        "files": {
          "nodes": [
            {
              "path": "Mathlib.lean",
              "additions": 1,
              "deletions": 0
            },
            {
              "path": "Mathlib/Geometry/Manifold/MeasureZero.lean",
              "additions": 150,
              "deletions": 0
            },
            {
              "path": "docs/references.bib",
              "additions": 14,
              "deletions": 0
            }
          ]
        },
        "headRefName": "mr_sard_measure_zero",
        "headRefOid": "6c678696eca6298971fff07181192e24056fcb5e",
        "headRepository": {
          "name": "mathlib4",
          "owner": {
            "login": "leanprover-community"
          }
        },
        "headRepositoryOwner": {
          "login": "leanprover-community"
        },
        "id": "PR_kwDOFcwZ1c5Z8l5Y",
        "isCrossRepository": false,
        "isDraft": false,
        "labels": {
          "nodes": [
            {
              "id": "MDU6TGFiZWwzMjcxMjQ0NzU5",
              "name": "WIP"
            },
            {
              "id": "LA_kwDOFcwZ1c8AAAABIFoUmw",
              "name": "merge-conflict"
            },
            {
              "id": "LA_kwDOFcwZ1c8AAAABViJYYw",
              "name": "t-differential-geometry"
            },
            {
              "id": "LA_kwDOFcwZ1c8AAAABViJqVA",
              "name": "t-measure-probability"
            }
          ]
        },
        "latestReviews": {
          "nodes": [
            {
              "id": "PRR_kwDOFcwZ1c5gfTOl",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "mo271"
              },
              "submittedAt": "2023-09-10T12:23:48Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5t8Mww",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "github-actions"
              },
              "submittedAt": "2024-01-25T19:38:26Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5g0Bu4",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "ADedecker"
              },
              "submittedAt": "2023-09-13T10:47:48Z"
            }
          ]
        },
        "maintainerCanModify": false,
        "mergeCommit": null,
        "mergeStateStatus": "DIRTY",
        "mergeable": "CONFLICTING",
        "mergedAt": null,
        "mergedBy": null,
        "milestone": null,
        "number": 7076,
        "potentialMergeCommit": null,
        "projectCards": {
          "nodes": []
        },
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "THUMBS_DOWN",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "LAUGH",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "HOORAY",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "CONFUSED",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "HEART",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "ROCKET",
            "users": {
              "nodes": []
            }
          },
          {
            "content": "EYES",
            "users": {
              "nodes": []
            }
          }
        ],
        "reviewDecision": null,
        "reviewRequests": {
          "nodes": []
        },
        "reviews": {
          "nodes": [
            {
              "id": "PRR_kwDOFcwZ1c5gfTOl",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "mo271"
              },
              "submittedAt": "2023-09-10T12:23:48Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5gfXMV",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "grunweg"
              },
              "submittedAt": "2023-09-10T14:09:29Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5gfaET",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "ADedecker"
              },
              "submittedAt": "2023-09-10T15:40:22Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5gfnqD",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "grunweg"
              },
              "submittedAt": "2023-09-10T19:21:48Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5g0Bu4",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "ADedecker"
              },
              "submittedAt": "2023-09-13T10:47:48Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5g4owS",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "grunweg"
              },
              "submittedAt": "2023-09-13T21:12:07Z"
            },
            {
              "id": "PRR_kwDOFcwZ1c5t8Mww",
              "body": "",
              "state": "COMMENTED",
              "author": {
                "login": "github-actions"
              },
              "submittedAt": "2024-01-25T19:38:26Z"
            }
          ]
        },
        "reviewThreads": {
          "nodes": [
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5OuTQn",
                    "body": "```suggestion\r\n\r\n```",
                    "createdAt": "2023-09-10T12:23:48Z",
                    "author": {
                      "login": "mo271"
                    }
                  },
                  {
                    "id": "PRRC_kwDOFcwZ1c5OuXcj",
                    "body": "Thanks a lot: I hope this does the trick.",
                    "createdAt": "2023-09-10T14:09:29Z",
                    "author": {
                      "login": "grunweg"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5Ouamm",
                    "body": "Why not make `I` implicit to begin with?",
                    "createdAt": "2023-09-10T15:36:53Z",
                    "author": {
                      "login": "ADedecker"
                    }
                  },
                  {
                    "id": "PRRC_kwDOFcwZ1c5Ouoxz",
                    "body": "`I` must be explicit in the definition of measure zero sets (otherwise, typeclass inference gets stuck several times).",
                    "createdAt": "2023-09-10T19:21:48Z",
                    "author": {
                      "login": "grunweg"
                    }
                  },
                  {
                    "id": "PRRC_kwDOFcwZ1c5O76w8",
                    "body": "Yes, but you already use `variable (I) in` for that that definition. In this case, my question is why usesure that\r\n```lean\r\nvariable ... (I : ModelWithCorners ℝ E H) ...\r\nvariable {I}\r\n```\r\ninstead of\r\n```lean\r\nvariable ... {I : ModelWithCorners ℝ E H} ...\r\n```",
                    "createdAt": "2023-09-13T10:47:48Z",
                    "author": {
                      "login": "ADedecker"
                    }
                  },
                  {
                    "id": "PRRC_kwDOFcwZ1c5O-ygk",
                    "body": "Ah, that: there's no good reason; I didn't think about this.",
                    "createdAt": "2023-09-13T21:12:07Z",
                    "author": {
                      "login": "grunweg"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5Ouap7",
                    "body": "```suggestion\r\nprotected lemma iUnion {ι : Type*} [Encodable ι] {s : ι → Set M}\r\n```",
                    "createdAt": "2023-09-10T15:38:38Z",
                    "author": {
                      "login": "ADedecker"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5Ouar1",
                    "body": "```suggestion\r\nprotected lemma union {s t : Set M} (hs : MeasureZero I s) (ht : MeasureZero I t) :\r\n    MeasureZero I (s ∪ t) := by\r\n```",
                    "createdAt": "2023-09-10T15:39:09Z",
                    "author": {
                      "login": "ADedecker"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5Ouat1",
                    "body": "The `:` should not be at the beginning of the line.",
                    "createdAt": "2023-09-10T15:40:04Z",
                    "author": {
                      "login": "ADedecker"
                    }
                  }
                ]
              }
            },
            {
              "comments": {
                "nodes": [
                  {
                    "id": "PRRC_kwDOFcwZ1c5XbjQW",
                    "body": "**[imports]** <sub>reported by [reviewdog](https://github.com/reviewdog/reviewdog) :dog:</sub><br>\n```suggestion\n```\n",
                    "createdAt": "2024-01-25T19:38:26Z",
                    "author": {
                      "login": "github-actions"
                    }
                  }
                ]
              }
            }
          ]
        },
        "closingIssuesReferences": {
          "nodes": []
        },
        "participants": {
          "nodes": [
            {
              "id": "MDQ6VXNlcjEwMTA1MDE2",
              "login": "grunweg"
            },
            {
              "id": "MDQ6VXNlcjQ4NjU2Nzkz",
              "login": "ADedecker"
            },
            {
              "id": "MDQ6VXNlcjEwODE4NDM0",
              "login": "sgouezel"
            },
            {
              "id": "MDQ6VXNlcjM0OTE2Mjc=",
              "login": "mo271"
            },
            {
              "id": "U_kgDOB75MNQ",
              "login": "leanprover-community-mathlib4-bot"
            }
          ]
        },
        "state": "OPEN",
        "statusCheckRollup": {
          "contexts": {
            "nodes": [
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDzoQ",
                "name": "Add annotations",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616591/job/20875113377"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDwxg",
                "name": "Cancel Previous Runs (CI)",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875112646"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3ED0Iw",
                "name": "Cancel Previous Runs (CI)",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875113507"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3ED0bw",
                "name": "Lint style",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616587/job/20875113583"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3ED0Lg",
                "name": "Lint style (fork)",
                "conclusion": "SKIPPED",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875113518"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDyaA",
                "name": "Lint style",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875113064"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDzrA",
                "name": "Check all files imported",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616587/job/20875113388"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDxig",
                "name": "Check all files imported (fork)",
                "conclusion": "SKIPPED",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875112842"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDwxQ",
                "name": "Check all files imported",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875112645"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDzEA",
                "name": "check workflows (fork)",
                "conclusion": "SKIPPED",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875113232"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDxhw",
                "name": "check workflows",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875112839"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDyYA",
                "name": "Build (fork)",
                "conclusion": "SKIPPED",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875113056"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3EDzMA",
                "name": "Build",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875113264"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3ED1Dg",
                "name": "Post-CI job (fork)",
                "conclusion": "SKIPPED",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616314/job/20875113742"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAE3E2Umg",
                "name": "Post-CI job",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://github.com/leanprover-community/mathlib4/actions/runs/7659616315/job/20875941018"
              },
              {
                "__typename": "CheckRun",
                "id": "CR_kwDOFcwZ1c8AAAAFLZaoFQ",
                "name": "Summary",
                "conclusion": "SUCCESS",
                "status": "COMPLETED",
                "detailsUrl": "https://dashboard.mergify.com/github/leanprover-community/repo/mathlib4/event-logs?pullRequestNumber=7076"
              }
            ]
          }
        },
        "title": "feat: define measure zero subsets of a manifold",
        "updatedAt": "2024-07-31T08:14:03Z",
        "url": "https://github.com/leanprover-community/mathlib4/pull/7076",
        "timelineItems": {
          "nodes": [
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mFmC3",
              "createdAt": "2023-09-10T07:51:29Z",
              "body": "awaiting-review",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAJndxJi",
              "createdAt": "2023-09-10T07:51:38Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "HeadRefForcePushedEvent",
              "id": "HRFPE_lADOFcwZ1c5wmFvNzwAAAAJnd15Z",
              "createdAt": "2023-09-10T07:56:18Z"
            },
            {
              "__typename": "HeadRefForcePushedEvent",
              "id": "HRFPE_lADOFcwZ1c5wmFvNzwAAAAJnd2eC",
              "createdAt": "2023-09-10T07:57:56Z"
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mFmZK",
              "createdAt": "2023-09-10T07:58:36Z",
              "body": "Sorry for the churn while trying to fix the .bib file. (Is there a way to apply the suggested fix automatically? I have biber, but not bibtool installed locally.) Edit: I'm giving up; I don't understand the new error. Can a kind soul help me, please?",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "AssignedEvent",
              "id": "AE_lADOFcwZ1c5wmFvNzwAAAAJnfPYl",
              "createdAt": "2023-09-10T11:20:47Z",
              "assignee": {
                "id": "MDQ6VXNlcjQ4NjU2Nzkz",
                "login": "ADedecker"
              }
            },
            {
              "__typename": "PullRequestReview",
              "id": "PRR_kwDOFcwZ1c5gfTOl",
              "createdAt": "2023-09-10T12:23:48Z",
              "body": "",
              "author": {
                "login": "mo271"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mF6Qu",
              "createdAt": "2023-09-10T14:12:23Z",
              "body": ".bib file is fixed now; the build lints.",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mF-_v",
              "createdAt": "2023-09-10T15:35:53Z",
              "body": "I have a few mathematical suggestions/options/random thoughts. They don't necessarily have to be taken into account for this PR, but I want to at least discuss them with you and @fpvandoorn (in fact you may have discussed some of them already in person). Disclaimer: I'm neither a geometer nor a measure theorist, but I'm a filter enthusiast :grin: \r\n\r\nRegarding which measure to consider, here are three natural options that come to my mind:\r\n1. You could pick a measure `μ` on the model space `E` and use that everywhere.\r\n2. If choosing a measure is too much, maybe it's better to choose a filter (probably with countable intersection) of declared co-null sets on the model space. \r\n3. Even if you want to only consider Haar measures, I think it's better to first define the filter of co-negligible sets for all/any Haar measure on the model space, and then move to manifolds. I think separating the two steps could make your life easier, for example showing that you only have to check *one* Haar measure will trivially follow from the case of the model space. I'm not sure if I'm clear here, feel free to ask for details :sweat_smile: \r\n\r\nThen, assuming you've fixed a filter `F` of co-null sets on your model space (either by 1., 2., or 3.), I think you can construct the `ae` filter directly as `⨆ e ∈ atlas H M, (comap (I ∘ e) F) ⊓ 𝓟 e.source`. I haven't tested it in Lean, but I'm pretty sure you recover your definition by using [Filter.mem_iSup](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.mem_iSup), [Filter.mem_inf_principal'](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.mem_inf_principal') and [Filter.compl_mem_comap](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.compl_mem_comap). I claim that this is, at least morally, the right way to define it, and then you can work with this filter as much as possible (in particular, being a null set is the same as being eventually equal to the empty set for this filter). \r\n\r\nRegarding notation, one possibility (definitely not in scope for this PR) would be to define an intermediate between `MeasurableSpace` and `MeasureSpace` where you don't have the measure yet but you know which sets are negligible. This would work well with option 2. above, but this would be a big refactor and I'm not sure how useful it is.",
              "author": {
                "login": "ADedecker"
              }
            },
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "PullRequestReview",
              "id": "PRR_kwDOFcwZ1c5gfaET",
              "createdAt": "2023-09-10T15:36:53Z",
              "body": "",
              "author": {
                "login": "ADedecker"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mF_bu",
              "createdAt": "2023-09-10T15:43:37Z",
              "body": "By the way, do you know of any case where the measure(s) you'd want to consider live on the model space (as opposed to the model vector space)?",
              "author": {
                "login": "ADedecker"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5wmFvNzwAAAAJng0WP",
              "createdAt": "2023-09-10T15:43:54Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAJng0WR",
              "createdAt": "2023-09-10T15:43:54Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7P265b",
                "name": "awaiting-author"
              }
            },
            {
              "__typename": "HeadRefForcePushedEvent",
              "id": "HRFPE_lADOFcwZ1c5wmFvNzwAAAAJni2c4",
              "createdAt": "2023-09-10T19:19:03Z"
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mGQRQ",
              "createdAt": "2023-09-10T19:19:29Z",
              "body": "Force-pushed: addressed review nits and squashed commits a little. No further changes.",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mGQ55",
              "createdAt": "2023-09-10T19:32:10Z",
              "body": "> By the way, do you know of any case where the measure(s) you'd want to consider live on the model space (as opposed to the model vector space)?\r\n\r\nI'm not fully sure if I'm answering *your* question --- but here goes.\r\nIn general, you care quite a bit about Sard's theorem for manifolds with boundary. One cute application is Hirsch's proof of the Brouwer fixed point theorem --- using Sard's theorem, for a hypothetical retraction $D^n\\to S^{n-1}$. More deeply, the Transversality Theorem (\"transversality is generic\") uses Sard's theorem for the local argument (and a globalisation procedure).\r\nMy definition currently excluded manifolds with boundary, for the reason mentioned in the TODO --- Floris and I presumed the current definition is simply too weak.\r\n\r\nI haven't thought much about whether I'd define measure zero using the model space or the vector space behind it.",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mGRfc",
              "createdAt": "2023-09-10T19:42:08Z",
              "body": "> > By the way, do you know of any case where the measure(s) you'd want to consider live on the model space (as opposed to the model vector space)?\r\n> \r\n> I'm not fully sure if I'm answering _your_ question --- but here goes. In general, you care quite a bit about Sard's theorem for manifolds with boundary. One cute application is Hirsch's proof of the Brouwer fixed point theorem --- using Sard's theorem, for a hypothetical retraction Dn→Sn−1. More deeply, the Transversality Theorem (\"transversality is generic\") uses Sard's theorem for the local argument (and a globalisation procedure). My definition currently excluded manifolds with boundary, for the reason mentioned in the TODO --- Floris and I presumed the current definition is simply too weak.\r\n> \r\n> I haven't thought much about whether I'd define measure zero using the model space or the vector space behind it.\r\n\r\nThinking about this some more: I personally only care about the Haar/Lebesgue measure on (spaces isomorphic to) $\\mathbb{R}^n$. These restrict to the canonical model spaces, but naturally live on the model vector space. I'm not aware of gaining anything by considering measures on the model spaces.",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mGSWu",
              "createdAt": "2023-09-10T19:59:45Z",
              "body": "> I have a few mathematical suggestions/options/random thoughts. They don't necessarily have to be taken into account for this PR, but I want to at least discuss them with you and @fpvandoorn (in fact you may have discussed some of them already in person). Disclaimer: I'm neither a geometer nor a measure theorist, but I'm a filter enthusiast 😁\r\n> \r\n> Regarding which measure to consider, here are three natural options that come to my mind:\r\n> \r\n>     1. You could pick a measure `μ` on the model space `E` and use that everywhere.\r\n> \r\n>     2. If choosing a measure is too much, maybe it's better to choose a filter (probably with countable intersection) of declared co-null sets on the model space.\r\n> \r\n>     3. Even if you want to only consider Haar measures, I think it's better to first define the filter of co-negligible sets for all/any Haar measure on the model space, and then move to manifolds. I think separating the two steps could make your life easier, for example showing that you only have to check _one_ Haar measure will trivially follow from the case of the model space. I'm not sure if I'm clear here, feel free to ask for details 😅\r\n> \r\n> \r\n> Then, assuming you've fixed a filter `F` of co-null sets on your model space (either by 1., 2., or 3.), I think you can construct the `ae` filter directly as `⨆ e ∈ atlas H M, (comap (I ∘ e) F) ⊓ 𝓟 e.source`. I haven't tested it in Lean, but I'm pretty sure you recover your definition by using [Filter.mem_iSup](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.mem_iSup), [Filter.mem_inf_principal'](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.mem_inf_principal') and [Filter.compl_mem_comap](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.compl_mem_comap). I claim that this is, at least morally, the right way to define it, and then you can work with this filter as much as possible (in particular, being a null set is the same as being eventually equal to the empty set for this filter).\r\n> \r\n> Regarding notation, one possibility (definitely not in scope for this PR) would be to define an intermediate between `MeasurableSpace` and `MeasureSpace` where you don't have the measure yet but you know which sets are negligible. This would work well with option 2. above, but this would be a big refactor and I'm not sure how useful it is.\r\n\r\nThanks for the fast response! These are interesting suggestions, I definitely hadn't thought about this before.\r\n\r\nFor me, it's important that the notion of measure zero sets is independent of auxiliary choices. (Sard's theorem doesn't mention any such choices, for instance.) Choosing a measure on the model space or model vector space induces a measure on the manifold --- but not canonically so. (Extending from each model space to the whole manifold needs a partition of unity, I believe --- which is very far from canonical. And you might have several measures on the model space to choose from. Let alone the fact that to me, the choice of model space (among isomorphic representatives) is not canonical either, and not what the manifold is really about. In other words, depending on that also doesn't feel natural to me.)\r\n\r\nIn effect, the resulting concept is either not canonical, or one needs to argue that all these choices yield the same result. My definition is this equivalent result.\r\n\r\nI haven't yet thought much about whether your approach would yield simpler *proofs*. (I only learned about filters last Wednesday - I think they're cool, but I'm not very *used* to them yet.) If you use filter, you also have to show independence of auxiliary choices; I'm not sure how much extra work that entails.\r\n",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mGSZp",
              "createdAt": "2023-09-10T20:00:37Z",
              "body": "Actually, I just wondered if measure zero sets are actually the canonical concept to consider. After all, for Sard's theorem in infinite dimensions (maps between Banach manifolds), the set of critical values is a meagre set --- there's no useful notion of \"measure zero\" any more. The right version of Sard's theorem in finite dimensions also goes in these terms, the critical set is meagre.\r\n\r\nThat said, measure zero sets are still used in the proof. (While in general, none of meagreness and measure zero implies the other, in a Baire space a $\\sigma$-compact measure zero set is meagre. The standard proof shows that the critical set has measure zero. It is also $\\sigma$-compact (the critical values are closed and the domain $M$ is $\\sigma$-compact), hence is meagre.\r\n\r\n\r\nThat is to say: I do think this definition is necessary for proving Sard's theorem. But a next step would be showing the implication above \"in a Baire space, a $\\sigma$-compact measure zero set is meagre\". (I haven't checked to what degree this is in mathlib already.)\r\n",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5wmFvNzwAAAAJoHQ7T",
              "createdAt": "2023-09-11T16:46:53Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7P265b",
                "name": "awaiting-author"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAJoHQ7b",
              "createdAt": "2023-09-11T16:46:53Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mXgr3",
              "createdAt": "2023-09-13T11:22:29Z",
              "body": "I agree that choosing a measure on the model space doesn't feel right. Note however that I didn't want to use it to construct a measure on the manifold, just to have a simpler definition of measure zero. \r\n\r\n> In effect, the resulting concept is either not canonical, or one needs to argue that all these choices yield the same result. My definition is this equivalent result.\r\n\r\nNote that, while this is morally true, this doesn't mean that you have less work to do: at some point you will still want to show that actually, testing measure zero for *all* measures or for *one* given Haar measure is the same, and the proof of that will essentially be what would have to be done to prove that the definition \"with a choice\" is actually independent from the choice. \r\n\r\n> I haven't yet thought much about whether your approach would yield simpler proofs. (I only learned about filters last Wednesday - I think they're cool, but I'm not very used to them yet.) If you use filter, you also have to show independence of auxiliary choices; I'm not sure how much extra work that entails.\r\n\r\nThe definition I proposed using filters doesn't need extra choices in itself, all the choices happen in the choice of the filter `F` on the model space (which will simplify the proof of the result I wrote just above). I'm happy to rule out `μ.ae` for a specific `μ`, but that could be `⨆ (μ : Measure E) [IsAddHaarMeasure μ], μ.ae`, which would give out exactly your definition, without making any additional choice. \r\nMy claim is that, on top of potentially simplifying the proof, the `ae` filter on the manifold is the natural object here, because it is precisely what's needed to encode \"P(x) is true for almost every x\", and \"S has measure zero\" is just the special case \"For almost every x, x is not in S\". Does that make sense? Another example is precisely Sard's theorem, which could be stated as \"almost all points in the codomain are regular values for f\" which would be more natural to work with (thanks to the extensive filter API) than the usual \"the set of critical values has measure zero\". \r\n\r\nRegarding using meagre sets, I think the notion of measure zero definitely deserves to exist in some form, independently of meagre sets. By the way, note that we have the same kind of filter for co-meagre sets, see [eventually_residual](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/MetricSpace/Baire.html#eventually_residual).",
              "author": {
                "login": "ADedecker"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mXrom",
              "createdAt": "2023-09-13T11:55:16Z",
              "body": "I have a mathematical problem with the current definition: there *is no* canonical notion of measure zero on a topological manifold, as homeomorphisms don't respect the Lebesgue measure class in general. You need a C^1 manifold to get a meaningful notion, so in mathlib we would probably require a smooth manifold for simplicity. In this setting, you have partitions of unity, so you can construct *a* Lebesgue measure. And it is often important to have a Lebesgue measure at our disposal, so why not first construct such a Lebesgue measure and then define measure zero with respect to this measure?",
              "author": {
                "login": "sgouezel"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5ma7Dq",
              "createdAt": "2023-09-13T21:21:43Z",
              "body": "Thanks for the detailed comments, @ADedecker @sgouezel! Let me respond to two points already; I'll have to ponder the others more deeply. (Given that you're suggesting different approaches, I want to, at least, make up my mind :smiley:)\r\n\r\n> I have a mathematical problem with the current definition: there _is no_ canonical notion of measure zero on a topological manifold, as homeomorphisms don't respect the Lebesgue measure class in general. You need a C^1 manifold to get a meaningful notion, so in mathlib we would probably require a smooth manifold for simplicity.\r\n\r\nVery good point, you're right. While the current definition can be *stated* for topological manifolds, it only makes sense for C¹ manifolds. (I thought about the C¹ aspect, but didn't connect the dots...)\r\n\r\n-------\r\n\r\nI also agree that the notion of \"almost everywhere\" is the conceptually useful one. (Sard's theorem, or the transversality theorem, are theorems about generic properties after all.) I would argue that the complementary notion still should be stated: for instance, the proof of Sard's theorem uses that measure zero sets are closed under countable unions. I wouldn't mind, though, proving all properties of measure zero sets by dualizing the results for the a.e. notion.\r\n",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5mgdIs",
              "createdAt": "2023-09-14T16:35:43Z",
              "body": "Let me summarize. My impression is that we all agree the statements in the PR (measure zero sets on a manifold generate a filter, which is closed under countable intersections) are worthwhile, we're just discussing the best way to prove them.\r\n\r\n@sgouezel If I understand correctly, you suggest to\r\n- define a Lebesgue measure on each $C^1$ (e.g., smooth) manifold by pulling back the Lebesgue measure on each chart and using a partition of unity\r\n- show that if $\\mu$ and $\\mu'$ are two such Lebesgue measure, we have $\\mu(A)=0$ iff $\\mu'(A)=0$. (This uses that C¹ maps are locally Lipschitz and those preserve measure zero sets.)\r\n- define measure zero sets as null sets w.r.t. any (or equivalently, all) Lebesgue measure(s) on $M$.\r\n- deduce: $A\\subseteq M$ has measure zero iff $\\phi(U\\cap A)$ has measure zero (w.r.t. the Haar measure), for each chart $(\\phi,U)$ of $M$\r\n- the countable intersection filter is then a special case of the a.e. filter on a general measure space.\r\n\r\n@ADedecker As I understand I, you suggest a different description of the a.e. filter on $M$: choose an a.e. filter on the model space $F$ (or even a measure) and define the a.e. filter on `M` using that. (The a.e. filter for the Haar measure should be canonical, as the Haar measure on Euclidean space is unique up to a multiplicative constant. Neat!)\r\n\r\nIt seems to me these ideas are complementary, and having both would certainly be worthwhile.\r\n\r\n------\r\n\r\nIn all applications I know (using Sard's theorem), measure zero sets are never used \"constructively\": you care that a particular property is generic, but you never need to know (nor care) if a *particular* set has measure zero. (I can imagine some applications care about this.) Making this definition more workable by relating to the Lebesgue measure is not a priority for me personally; yet, this is certainly useful and belongs to mathlib.\r\n\r\nI'm unsure of the best way forward. My lean time in the next few months is rather limited; I'm not sure if I have the capacity to redo the proof as above *soon*. (I do intend to eventually return to this for sure!)\r\n\r\nWriting down the Lebesgue measure definition is not too hard, I guess. I have in-progress code for parenthetical in point 2 (needing some review, but perhaps I can finish that/push here). I cannot estimate the amount of work necessary for the filters approach.",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAJqYCtT",
              "createdAt": "2023-09-14T16:36:30Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABViJYYw",
                "name": "t-differential-geometry"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAJqYCtg",
              "createdAt": "2023-09-14T16:36:31Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABViJqVA",
                "name": "t-measure-probability"
              }
            },
            {
              "__typename": "BaseRefChangedEvent"
            },
            {
              "__typename": "BaseRefChangedEvent"
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5wmFvNzwAAAAJupAmc",
              "createdAt": "2023-09-22T11:08:24Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAJupAmn",
              "createdAt": "2023-09-22T11:08:24Z",
              "label": {
                "id": "MDU6TGFiZWwyOTg0NTM0NDU0",
                "name": "help-wanted"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAJupAmv",
              "createdAt": "2023-09-22T11:08:24Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7P265b",
                "name": "awaiting-author"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5nMJd7",
              "createdAt": "2023-09-22T11:09:37Z",
              "body": "**Status update.** I intend to focus on finishing my PhD thesis in the next months, hence will put this aside for now. (I intend to return to it.) Help is welcome. \r\n\r\nNext steps, as I see them.\r\n1. Define Lebesgue measure on a C¹ manifold (pull back Lebesgue measure on each chart, use a partition of unity).\r\n2. Re-define: a measure zero subset of a manifold is a null set w.r.t. one (or any) Lebesgue measure.\r\n3. Show step 2 is well-defined: null sets on $\\mathbb{R}^n$ are preserved by coordinate changes.\r\n4. Show: $A \\subseteq M$$ has measure zero iff for each chart $(\\phi,U)$, the set $\\phi(U\\cap A)$ is a null set.\r\n5. Define the almost everywhere filter on a manifold, show it's a `CountableIntersectionFilter`.\r\n5. Show the ae filter is induced from the ae filter on the charts.\r\n\r\nI have worked towards step 3: a more conceptual version holds for locally Lipschitz maps metric metric spaces.\r\n- #7314 defines locally Lipschitz maps (and shows C¹ maps are locally Lipschitz)\r\n- I [have proven](https://github.com/fpvandoorn/sard/blob/master/Sard/LocallyLipschitzMeasureZero.lean) that locally Lipschitz maps preserve measure zero sets. (A version on an open set is almost done.)\r\n- In fact, mathlib has most of this already, via `ContDiffOn.dimH_image_le`.",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAKs8pvY",
              "createdAt": "2024-01-15T19:21:01Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABIFoUmw",
                "name": "merge-conflict"
              }
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5x5QBp",
              "createdAt": "2024-01-25T19:18:55Z",
              "body": "A few months later, I'd like to move this forward again. In the above, I see requests to\r\n- define a Lebesgue measure on (finite-dimensional) manifolds and define measure zero sets this way\r\n(then deducing the equivalence to the current definition)\r\n- write the almost everywhere filter in terms of the filter in charts\r\n\r\nI'm ready to do (1), but there is one catch: constructing Lebesgue measure on a manifold commonly proceeds using Riemannian metrics. (For instance, as \"for each Riemannian metric on M, there's a corresponding Lebesgue measure\" and showing that measure zero sets are independent of this choice.) As I understand it, however, Riemannian metrics are still some way off, in the sense that @hrmacbeth has a definition written down which is not suitable for entering mathlib yet.\r\n\r\nMore generally, that seems like a phenomenal expansion of this PR's scope, as it would entail\r\n1. defining oriented atlasses and orientations of a finite-dimensional manifold\r\n2. some definition of Riemannian metric\r\n(yes, there is a theory of sprays for Banach manifolds: perhaps we can restrict to finite-dimensional manifolds for now)\r\n3. showing finite-dimensional smooth manifolds admit a Riemannian metric\r\n4. use that to define a Lebesgue measure\r\n5. show there is a unique Lebesgue measure, given a Riemannian metric\r\nAll of this is good and useful work, but need it block this PR?\r\n\r\nIs there some middle ground: for instance, by\r\n- defining continuous Riemannian metrics for now\r\n(upgrading this to smooth can happen when the kinks with smooth vector bundles are ironed out)\r\n- defining the Lebesgue measure\r\n- showing that a set has measure zero iff each image in charts has; this also shows independence of the chosen measure\r\n\r\n@sgouezel I would be interested in your opinion here.",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "MentionedEvent"
            },
            {
              "__typename": "SubscribedEvent"
            },
            {
              "__typename": "PullRequestCommit"
            },
            {
              "__typename": "PullRequestCommit"
            },
            {
              "__typename": "PullRequestCommit"
            },
            {
              "__typename": "PullRequestCommit"
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5wmFvNzwAAAAKzgS1x",
              "createdAt": "2024-01-25T19:30:58Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABIFoUmw",
                "name": "merge-conflict"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAKzgZpo",
              "createdAt": "2024-01-25T19:34:04Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABIFoUmw",
                "name": "merge-conflict"
              }
            },
            {
              "__typename": "HeadRefForcePushedEvent",
              "id": "HRFPE_lADOFcwZ1c5wmFvNzwAAAAKzgkZK",
              "createdAt": "2024-01-25T19:38:09Z"
            },
            {
              "__typename": "PullRequestReview",
              "id": "PRR_kwDOFcwZ1c5t8Mww",
              "createdAt": "2024-01-25T19:38:26Z",
              "body": "",
              "author": {
                "login": "github-actions"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5wmFvNzwAAAAKzglEw",
              "createdAt": "2024-01-25T19:38:30Z",
              "label": {
                "id": "MDU6TGFiZWwyOTg0NTM0NDU0",
                "name": "help-wanted"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5wmFvNzwAAAAKzglE0",
              "createdAt": "2024-01-25T19:38:30Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABIFoUmw",
                "name": "merge-conflict"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5wmFvNzwAAAAKzglUb",
              "createdAt": "2024-01-25T19:38:38Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7P265b",
                "name": "awaiting-author"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAKzglUu",
              "createdAt": "2024-01-25T19:38:38Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "PullRequestCommit"
            },
            {
              "__typename": "HeadRefForcePushedEvent",
              "id": "HRFPE_lADOFcwZ1c5wmFvNzwAAAAKzgquU",
              "createdAt": "2024-01-25T19:40:55Z"
            },
            {
              "__typename": "IssueComment",
              "id": "IC_kwDOFcwZ1c5x5cYd",
              "createdAt": "2024-01-25T19:47:44Z",
              "body": "Sorry for the force-push: I just squashed the previous commits, merged master and made a new commit golfing things.\r\nGiven that my understanding is this won't be merged as-is anyway, I felt fine with this.",
              "author": {
                "login": "grunweg"
              }
            },
            {
              "__typename": "UnlabeledEvent",
              "id": "UNLE_lADOFcwZ1c5wmFvNzwAAAALHQt2L",
              "createdAt": "2024-02-27T08:58:54Z",
              "label": {
                "id": "LA_kwDOFcwZ1c7ECuhA",
                "name": "awaiting-review"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAALHQt2Z",
              "createdAt": "2024-02-27T08:58:54Z",
              "label": {
                "id": "MDU6TGFiZWwzMjcxMjQ0NzU5",
                "name": "WIP"
              }
            },
            {
              "__typename": "LabeledEvent",
              "id": "LE_lADOFcwZ1c5wmFvNzwAAAAMVxeAS",
              "createdAt": "2024-06-22T09:23:52Z",
              "label": {
                "id": "LA_kwDOFcwZ1c8AAAABIFoUmw",
                "name": "merge-conflict"
              }
            }
          ]
        }
      }
    }
  }
}
